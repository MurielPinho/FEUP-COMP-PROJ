options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)

import java.util.*;
import java.io.*;

import java.io.StringReader;

public class Parser {
    private int whileExpressionErrorsCounter = 0;
    private int MAX_WHILE_EXPRESSION_ERRORS = 300;
    private ArrayList<String> errorMessages = new ArrayList<String>();

    public Parser(String stringReader) throws ParseException, FileNotFoundException{
        System.out.println("Parsing...");

        System.setIn(new FileInputStream(stringReader));
		Parser parser = new Parser(System.in);
		SimpleNode root = parser.Program();  // returns reference to root node

		root.dump(""); // prints the tree on the screen
    }

    /* Skips the while expression until if finds the token "{" */
    public void skipWhileExpression() {
        Token prev; // will store the previous token

        do{
            prev = token;
            token = getNextToken();
        } while(token.kind != LBRACKET && token.kind != EOF);

        if(token.kind == LBRACKET)
            token = prev;
    }

    /* Handles with while expression error */
    public void handleWhileExpressionError(ParseException exception) throws ParseException {
        whileExpressionErrorsCounter++;
        
        if(whileExpressionErrorsCounter > this.MAX_WHILE_EXPRESSION_ERRORS) {
            System.out.println("Maximum Number of While Expression Errors(" + this.MAX_WHILE_EXPRESSION_ERRORS + ") exceeded.");
            this.printErrorMessages();
            throw new ParseException();
        }
        else this.buildErrorMessage(exception);
       
        skipWhileExpression();
    }

    private void buildErrorMessage(ParseException exception) {
        this.errorMessages.add("Error Number "+ whileExpressionErrorsCounter + " -> " + exception);
    }

    private void printErrorMessages() {
        for(int i = 0; i < this.errorMessages.size(); i++)
            System.out.println(this.errorMessages.get(i));
    }
}


PARSER_END(Parser)

SKIP :
{    < "//" (~["\r", "\n"])* >
    | < "/*" > : COMMENTS
	| " " | "\r" | "\t" | "\n"
}

<COMMENTS> SKIP :
{
  < "*/" > : DEFAULT
| < ~[] >
}



TOKEN:
{
        <IF: "if">
    |   <INT: "int">
    |   <NEW: "new">
    |   <VOID: "void">
    |   <ELSE: "else">
    |   <TRUE: "true">
    |   <MAIN: "main">
    |   <THIS: "this">
    |   <WHILE: "while">
    |   <FALSE: "false">
    |   <CLASS: "class">
    |   <PUBLIC: "public">
    |   <STATIC: "static">
    |   <STRING: "String">
    |   <LENGTH: "length">
    |   <RETURN: "return">
    |   <IMPORT: "import">
    |   <BOOLEAN: "boolean">
    |   <EXTENDS: "extends">
    |   <LBRACKET: "{">
    |   <RBRACKET: "}">
    |   <LPAR: "(">
    |   <RPAR: ")">
    |   <LRPAR: "[">
    |   <RRPAR: "]">
    |   <NOT: "!">
    |   <DOT: ".">
    |   <EQUAL: "=">
    |   <VIRG: ",">
    |   <PVIRG: ";">
    |   <AND: "&&">
    |   <LESS: "<">
    |   <PLUS: "+">
    |   <MINUS: "-">
    |   <MULT: "*">
    |   <DIV: "/">
    |   <IDENTIFIER: ((["$"]|["_"]|["A"-"Z"]|["a"-"z"])(["$"]|["0"-"9"]|["A"-"Z"]|["a"-"z"]|["_"])*)>
	|   <INTEGERLITERAL: (["0"-"9"])+ >

}

SimpleNode Program(): {}
{
    ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;}
}

void ImportDeclaration()  #Imports: {
    Token base, comp;
    String importText = "";
}
{
   (<IMPORT> base = <IDENTIFIER> (<DOT> comp = <IDENTIFIER> {importText += "." + comp.image;})*
   <PVIRG> {jjtThis.val = base.image + importText;} #Import(0))*
}

void ClassDeclaration() #Class: {
    Token name, comp;
}
{
    <CLASS> name = <IDENTIFIER> {jjtThis.val = name.image;} (<EXTENDS> comp = <IDENTIFIER> {jjtThis.val += " " + comp.image;})? <LBRACKET>
        (VarDeclaration())*
        (MethodDeclaration())*
    <RBRACKET>
}

void VarDeclaration(): {}
{
    Type() VarDeclaration1()
}

void VarDeclaration1() #VarId:{
    Token id;
}
{
    id = <IDENTIFIER> {jjtThis.val = id.image;} <PVIRG>
}

void MethodDeclaration(): {}
{
    <PUBLIC> (RegularMethod() | Main())
}

void RegularMethod(): {
    Token name;
} 
{
    Type() #ReturnType name = <IDENTIFIER> {jjtThis.val = name.image;} <LPAR> (MethodParams())? <RPAR> <LBRACKET>
        MethodBody() #MethodBody
        <RETURN> Expression() #ReturnStatement <PVIRG>
    <RBRACKET>
}

void Main(): {} {
    <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LRPAR> <RRPAR> <IDENTIFIER> <RPAR> <LBRACKET>
        MethodBody() #MethodBody
    <RBRACKET>
}

void MethodParams():{}
{
    MethodParam() (<VIRG> MethodParam())*
}

void MethodParam(): {
    Token name;
}
{
    Type() name = <IDENTIFIER> {jjtThis.val = name.image;} #VarId(0)
}

void MethodBody() #void: {
    Token type;
}
{
    (
        (type = <IDENTIFIER> {jjtThis.val = type.image;} #Type(0) ((VarDeclaration1() #VarDeclarartion(2) MethodBody())
        | (Statement2() (Statement())*)))
        | (Type1() VarDeclaration1() #VarDeclarartion(2) MethodBody())
        | (Statement1() (Statement())*)
    )?
}

void Type() #void: {
    Token type;
}
{
    Type1() | type = <IDENTIFIER> {jjtThis.val = type.image;} #Type(0)
}

void Type1() #void:{}
{
    (<INT> {jjtThis.val = "int";} (<LRPAR> <RRPAR> {jjtThis.val = "[]";})?) #Type(0) | <BOOLEAN> {jjtThis.val = "boolean";} #Type(0)
}

void Statement() #void: {
    Token name;
}
{
    Statement1()
    | (name = <IDENTIFIER> {jjtThis.val = name.image;} Statement2()) #Var
}

void Statement1() #void:{}
{
    Scope()
    | IfAndElse()
    | While()
    ->| (Expression3() Expression1() <PVIRG>)
}

void Statement2() #void:{}
{
    Assignment()
    ->| (<LRPAR> Expression() <RRPAR> #Array(3) (Assignment())?) 
    ->| (Expression4() <PVIRG>)
}

void Assignment():{}
{
    <EQUAL> Expression() <PVIRG>
}

void Scope():{}
{
    <LBRACKET> (Statement())* <RBRACKET>
}

void IfAndElse():{}
{
    <IF> IfExpression() IfBody() <ELSE> ElseBody()
}

void IfExpression():{}
{
    <LPAR> Expression() <RPAR>
}

void IfBody():{}
{
    Statement()
}

void ElseBody():{}
{
    Statement()
}

void While():{}
{
    try{
        <WHILE> WhileExpression()
    }
    catch(ParseException e) {
        handleWhileExpressionError(e);
    }
    WhileBody()
}

void WhileExpression():{}
{
    <LPAR> Expression() <RPAR>
}

void WhileBody():{}
{
    Statement()
}

void Expression() #void: {}
{
    Expression2() Expression1()
}

void Expression1() #void:{}
{
    Expression4()
    | (<LRPAR> Expression2() Expression1() <RRPAR>) #Index(2)
    | {}
}

void Expression2() #void:{
  Token name;
}
{
    ->Expression3() | name = <IDENTIFIER> {jjtThis.val = name.image;}
}

void Expression3() #void:{
  Token name, comp;
}
{
    name = <INTEGERLITERAL> {jjtThis.val = name.image;} #IntegerLiteral(0)
    | <TRUE> #True(0)
    | <FALSE> #False(0)
    | <THIS> #This(0)
    -> | (comp = <NEW> {jjtThis.val = comp.image;}((name = <IDENTIFIER> {jjtThis.val = name.image;} <LPAR> <RPAR>) #Constructor(4)
    ->											| (name = <INT> {jjtThis.val = name.image;} <LRPAR> Expression2() Expression1() <RRPAR> #NewIntArray(5))))
    | (<NOT> Expression2() Expression1() #Not(2))
    ->| (<LPAR> Expression2() Expression1() <RPAR>)
}

void Expression4() #void:{
  Token name, base1, base2, comp1, comp2;
  String otherParams = "";
  String baseString = "";
  String compString = "";
}
{
    ((<AND> #And(0)
     |<LESS> #Less(0)
     |<PLUS> #Plus(0)
     |<MINUS> #Minus(0)
     |<MULT> #Mult(0)
     |<DIV> #Div(0)) Expression2() Expression1())
    | (<DOT> #DOT(0) ((<LENGTH>) #Length(0) 
    ->| (name = <IDENTIFIER> {jjtThis.val = name.image;} <LPAR> (base2 = Expression2() {baseString += base2.image;} base1 = Expression1() {baseString += base1.image;} #Parameter(2) {jjtThis.val = baseString;}
    ->(<VIRG> comp2 = Expression2() {compString += comp2.image;} comp1 = Expression1() {compString += comp1.image;} #Parameter(3) {jjtThis.val = compString; otherParams += ", " + compString; compString = "";})*)? <RPAR>)) #Method)
}
