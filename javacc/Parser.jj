options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)

import java.util.*;
import java.io.*;

import java.io.StringReader;


public class Parser {
    private static int whileExpressionErrorsCounter;

    public Parser(String stringReader) throws ParseException, FileNotFoundException{
        this.whileExpressionErrorsCounter = 0;

        System.out.println("Parsing...");

        System.setIn(new FileInputStream(stringReader));
		Parser myProg = new Parser(System.in);
        myProg.Program();

		/*SimpleNode root = Program(); */ // returns reference to root node

		//root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }

    /* Skips the while expression until if finds the token "{" */
    public static void skipWhileExpression() {
        do{
           Token token = getNextToken(); 
           if(token.kind != 0) System.out.println(token.kind);
        } while(token.kind != LBRACKET && token.kind != 0);
    }

    /* Handles with while expression error */
    public static void handleWhileExpressionError(ParseException exception) {
        System.out.println("Error on while");
        System.out.println(exception.currentToken);
        
        whileExpressionErrorsCounter++;
        if(whileExpressionErrorsCounter > 10) {
            System.out.println("STOP!!!");
        }

        skipWhileExpression();
    }
}


PARSER_END(Parser)

SKIP :
{    < "//" (~["\r", "\n"])* >
    | < "/*" > : COMMENTS
	| " " | "\r" | "\t" | "\n"
}

<COMMENTS> SKIP :
{
  < "*/" > : DEFAULT
| < ~[] >
}



TOKEN:
{
        <IF: "if">
    |   <INT: "int">
    |   <NEW: "new">
    |   <VOID: "void">
    |   <ELSE: "else">
    |   <TRUE: "true">
    |   <MAIN: "main">
    |   <THIS: "this">
    |   <WHILE: "while">
    |   <FALSE: "false">
    |   <CLASS: "class">
    |   <PUBLIC: "public">
    |   <STATIC: "static">
    |   <STRING: "String">
    |   <LENGTH: "length">
    |   <RETURN: "return">
    |   <IMPORT: "import">
    |   <BOOLEAN: "boolean">
    |   <EXTENDS: "extends">
    |   <LBRACKET: "{">
    |   <IDENTIFIER: ((["$"]|["_"]|["A"-"Z"]|["a"-"z"])(["$"]|["0"-"9"]|["A"-"Z"]|["a"-"z"]|["_"])*)>
	|   <INTEGERLITERAL: (["0"-"9"])+ >

}

void Program(): {}
{
    ImportDeclaration() ClassDeclaration() <EOF>
}

void ImportDeclaration(): {}
{
   (<IMPORT> <IDENTIFIER> ("." <IDENTIFIER>)* ";")*
}

void ClassDeclaration(): {}
{
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? "{"
    (VarDeclaration())*
    (MethodDeclaration())*
    "}"
}

void VarDeclaration(): {}
{
    Type() VarDeclaration1()
}

void VarDeclaration1():{}
{
    <IDENTIFIER> ";"
}

void MethodDeclaration(): {}
{
    <PUBLIC> 
    ((
        Type() <IDENTIFIER> "(" (Type() <IDENTIFIER> ("," Type() <IDENTIFIER>)*)? ")" "{"
        MethodBody()
        "return" Expression() ";"
        "}"
    ) 
    | 
    (
        <STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" <IDENTIFIER> ")" "{"
        MethodBody() ";"
        "}"
    ))
}

void MethodBody(): {}
{
    (
        (<IDENTIFIER>((VarDeclaration1() MethodBody()) | (Statement2() (Statement())*)))
        | (Type1() VarDeclaration1() MethodBody())
        | (Statement1() (Statement())*)
    )?
}

void Type(): {}
{
    Type1() | <IDENTIFIER>
}

void Type1():{}
{
    (<INT> ("[" "]")?) | <BOOLEAN>
}

void Statement(): {}
{
    Statement1()
    | (<IDENTIFIER> Statement2())
}

void Statement1():{}
{
    "{" (Statement())* "}"
    | (<IF> "(" Expression() ")" Statement() <ELSE> Statement())
    | While()
    | (Expression3() Expression1() ";")
}

void While():{}
{
    try{
        <WHILE> WhileExpression()
    }
    catch(ParseException e) {
        handleWhileExpressionError(e);
    }
    Statement()
}

void WhileExpression():{}
{
    "(" Expression() ")" 
}

void Statement2():{}
{
    ("=" Expression() ";") | ("[" Expression() "]" ("=" Expression() ";")?) | Expression5()
}

void Expression(): {}
{
    Expression2() Expression1()
}

void Expression1():{}
{
    Expression5()
    | ("[" Expression2() Expression1() "]")
    | {}
}

void Expression2():{}
{
    Expression3() | <IDENTIFIER>
}

void Expression3():{}
{
    <INTEGERLITERAL> | <TRUE> | <FALSE> | <THIS> | (<NEW> ((<IDENTIFIER> "(" ")") | (<INT> "[" Expression2() Expression1() "]")))
    | ("!" Expression2() Expression1())
    | ("(" Expression2() Expression1() ")")
}

void Expression5():{}
{
    (("&&" | "<" | "+" | "-" | "*" | "/") Expression2() Expression1())
    | ("." (("length") | (<IDENTIFIER> "(" (Expression2() Expression1() ("," Expression2() Expression1())*)? ")")))
}